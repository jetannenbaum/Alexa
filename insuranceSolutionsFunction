// Developed for the sole use of United Healthcare
// Developer: J.E. Tannenbaum
// Revision : 1.0.0.0
// History  : 05/02/2018 - Initial release for demonstarion

const invocationName = "insurance solutions";

const languageStrings = {
   'en': {
        'translation': {
            'WELCOME1' : 'Welcome to insurance solutions!',
            'HELP'    : 'You can say help, stop, or cancel. ',
            'STOP'    : 'Goodbye!'
        }
    }
};
const APP_ID = 'amzn1.ask.skill.281d9a53-5ccc-4f8d-94c7-36b96fd33dd9';

const Alexa = require("alexa-sdk");
const https = require("https");

exports.handler = function(event, context, callback) {
    let alexa = Alexa.handler(event, context);
    alexa.appId = APP_ID; // 

    alexa.resources = languageStrings;
 // alexa.dynamoDBTableName = "myTable"; // persistent session attributes
    alexa.registerHandlers(handlers);
    alexa.execute();
};

const handlers = {
    'AMAZON.FallbackIntent': function () {
        let say = 'Invalid response.  Please ask for help. ';

        this.response
          .speak(say)
          .listen('try again, ' + say)
          .cardRenderer('AMAZON.FallbackIntent', '');


        this.emit(':responseReady'); 
    },
    'AMAZON.CancelIntent': function () {

        let say = 'Goodbye.';
        this.response
          .speak(say);

        this.emit(':responseReady'); 
    },
    'AMAZON.HelpIntent': function () {

        var CustomIntents = getCustomIntents();
        var MyIntent = randomPhrase(CustomIntents);
        let say = 'Just say, ' + MyIntent.samples[MyIntent.samples.length - 1];
        this.response
          .speak(say)
          .listen('try again, ' + say)
          .cardRenderer('Intent List', cardIntents(CustomIntents)); // , welcomeCardImg

        this.emit(':responseReady'); 
    },
    'AMAZON.StopIntent': function () {

        let say = 'Goodbye.';
        this.response
          .speak(say);

        this.emit(':responseReady'); 
    },
    'rateIntent': function () {
        // delegate to Alexa to collect all the required slots 
        let isTestingWithSimulator = false; //autofill slots when using simulator, dialog management is only supported with a device 
        let filledSlots = delegateSlotCollection.call(this, isTestingWithSimulator); 
 
        if (!filledSlots) { 
            return; 
        } 
 
        console.log("filled slots: " + JSON.stringify(filledSlots)); 
        // at this point, we know that all required slots are filled. 
        let slotValues = getSlotValues(filledSlots); 
 
        console.log(JSON.stringify(slotValues)); 
 
        let birthDate = new Date(slotValues.dobSlot.resolved);
        let dob = birthDate.getFullYear() + pad(birthDate.getMonth() + 1) + pad(birthDate.getDate());
        let partBEffDate = (birthDate.getFullYear() + 65) + pad(birthDate.getMonth() + 1) + '01';
        let planType = slotValues.planSlot.resolved;

        getStateFromZipCode(this, planType, dob, partBEffDate,
            slotValues.zipCodeSlot.resolved,  slotValues.smokerSlot.resolved, 
            slotValues.healthySlot.resolved, function(stateCode) {
                  
            console.log('getStateFromZipCode Response: ' + stateCode);
        });
     },
    'LaunchRequest': function () {
        let say = randomPhrase([this.t('WELCOME1')] )  + ' ' + this.t('HELP');
        this.response
          .speak(say)
          .listen('try again, ' + say);

        this.emit(':responseReady'); 
    },
    'Unhandled': function () {
        let say = 'The skill did not quite understand what you wanted.  Do you want to try something else? ';
        this.response
          .speak(say)
          .listen(say);
}};
//  ------ Helper Functions -----------------------------------------------
function pad(n) {
    return (n<10 ? '0'+n : n);
}

function getStateFromZipCode(myThis, planType, dob, partBEffDate,
                             zipCode, smoker, healthy, callback) {
        var options = {
        host: 'acesx.uhc.com',
        port: 443,
        path: '/productservices/statebyzip/' + zipCode,
        method: 'GET',
    };
    var req = https.request(options, function (res) {
        var dataStr = '';

        res.setEncoding('utf8');

        res.on('data', function(chunk) {
            dataStr += chunk;
        });

        res.on('end', function ()
        {
            console.log(dataStr);
            var json = JSON.parse(dataStr);
            var stateCode = json[0].stateCode;

            console.log('State: ' + stateCode + ' for zip code: ' + zipCode);
            
            var params = [planType, dob, partBEffDate, stateCode,
                          zipCode, smoker, healthy];

            callAPI(myThis, params, function(wsText) {
                console.log('callAPI Response: ' + wsText);
            });
            
            callback(stateCode);
        });

    }).on('error', err => console.log('Error Received: ' + err));
    req.end();
}

function callAPI(myThis, params, callback) {
 
        var myParams = 'State='+params[3] +
           '&ProductType=MedSupp' +
           '&Zip='+ params[4] +
           '&DOB='+ params[1] + 
           '&PartBEffectiveDate='+ params[2] +
           '&PlanDisplayCode=' + params[0] +
           '&isTobaccoUser=' + (params[5] == 'smoker' ? 'true' : 'false') +
           '&hasHealthHistory=' + (params[6] == 'healthy' ? 'false' : 'true') +
           '&MessageConsumer=OLE';

        var options = {
        host: 'acesx.uhc.com',
        port: 443,
        path: '/is_rqs/quote/v2?' + myParams,
        method: 'GET',
    };

    var url = options.host + options.path;

    console.log('Requesting: ' + url);

    var req = https.request(options, function (res) {
        var dataStr = '';

        res.setEncoding('utf8');

        res.on('data', function(chunk) {
            dataStr += chunk;
        });

        res.on('end', function ()
        {
            var speechOutput = '';
            console.log(dataStr);
            
            try
            {
                var json = JSON.parse(dataStr);
                var results = json.data.d.results;
                var intRate = parseInt(results[0].Rate, 10);
                var floatRate = parseFloat(results[0].Rate).toFixed(2);
                var cents = ((floatRate - intRate).toFixed(2)) * 100;
    
                speechOutput = results[0].RateDescription + ' is ' + intRate + ' dollars';
                
                if (floatRate > intRate)
                {
                    speechOutput += ' and ' + cents + ' cents';
                }
    
                for (var i = 1, len = results.length; i < len; i++)
                {
                    intRate = parseInt(results[i].Rate, 10);
                    floatRate = parseFloat(results[i].Rate).toFixed(2);
                    
                    speechOutput += ', ' + results[i].RateDescription + ' is ' + intRate + ' dollars';
                
                if (floatRate > intRate)
                    {
                        cents = ((floatRate - intRate).toFixed(2)) * 100;
                        speechOutput += ' and ' + cents + ' cents';
                    }
                }
            }
            catch(error)
            {
                console.log('Error: ' + error);
                speechOutput = 'Sorry, a rate was not found for that request.  Please try again.';
            }
            console.log(speechOutput);
            myThis.response.speak(speechOutput).cardRenderer('Insurance Solutions', speechOutput); 
            myThis.emit(':responseReady');
            
            callback(speechOutput);
        });

    }).on('error', err => console.log('Error Received: ' + err));
    req.end();
}


function randomPhrase(myArray) {
    return(myArray[Math.floor(Math.random() * myArray.length)]);
}

// returns slot resolved to an expected value if possible
function resolveCanonical(slot){
    try {
        var canonical = slot.resolutions.resolutionsPerAuthority[0].values[0].value.name;
    } catch(err){
        console.log(err.message);
        canonical = slot.value;
    }
    return canonical;
}

// used to emit :delegate to elicit or confirm Intent Slots
function delegateSlotCollection(){
    console.log("current dialogState: " + this.event.request.dialogState);
    if (this.event.request.dialogState === "STARTED") {
        var updatedIntent = this.event.request.intent;

        this.emit(":delegate");

    } else if (this.event.request.dialogState !== "COMPLETED") {

        this.emit(":delegate");

    } else {
        console.log("returning: "+ JSON.stringify(this.event.request.intent));

        return this.event.request.intent;
    }
}

function getCustomIntents() {
    var customIntents = [];
    for (let i = 0; i < intentsReference.length; i++) {
        if(intentsReference[i].name.substring(0,7) != "AMAZON." && intentsReference[i].name !== "LaunchRequest" ) {
            customIntents.push(intentsReference[i]);
        }
    }
    return(customIntents);
}
function cardIntents(iArray) {
    var body = "";    for (var i = 0; i < iArray.length; i++) {
        body += iArray[i].name + "\n";
        body += "  '" + iArray[i].samples[0] + "'\n";
    }
    return(body);
}

const welcomeCardImg = {
    smallImageUrl: "https://m.media-amazon.com/images/G/01/mobile-apps/dex/alexa/alexa-skills-kit/alexa-devs-skill/cards/skill-builder-720x480._TTH_.png",
    largeImageUrl: "https://m.media-amazon.com/images/G/01/mobile-apps/dex/alexa/alexa-skills-kit/alexa-devs-skill/cards/skill-builder-1200x800._TTH_.png"
};

 
// *********************************** 
// ** Helper functions from 
// ** These should not need to be edited 
// ** www.github.com/alexa/alexa-cookbook 
// *********************************** 
 
// *********************************** 
// ** Route to Intent 
// *********************************** 
 
// after doing the logic in new session, 
// route to the proper intent 
 
function routeToIntent() { 
 
    switch (this.event.request.type) { 
        case 'IntentRequest': 
            this.emit(this.event.request.intent.name); 
            break; 
        case 'LaunchRequest': 
            this.emit('LaunchRequest'); 
            break; 
        default: 
            this.emit('LaunchRequest'); 
    } 
} 
 
// *********************************** 
// ** Dialog Management 
// *********************************** 
 
function getSlotValues (filledSlots) { 
    //given event.request.intent.slots, a slots values object so you have 
    //what synonym the person said - .synonym 
    //what that resolved to - .resolved 
    //and if it's a word that is in your slot values - .isValidated 
    let slotValues = {}; 
 
    console.log('The filled slots: ' + JSON.stringify(filledSlots)); 
    Object.keys(filledSlots).forEach(function(item) { 
        //console.log("item in filledSlots: "+JSON.stringify(filledSlots[item])); 
        var name = filledSlots[item].name; 
        //console.log("name: "+name); 
        if(filledSlots[item]&& 
            filledSlots[item].resolutions && 
            filledSlots[item].resolutions.resolutionsPerAuthority[0] && 
            filledSlots[item].resolutions.resolutionsPerAuthority[0].status && 
            filledSlots[item].resolutions.resolutionsPerAuthority[0].status.code ) { 
 
            switch (filledSlots[item].resolutions.resolutionsPerAuthority[0].status.code) { 
                case "ER_SUCCESS_MATCH": 
                    slotValues[name] = { 
                        "synonym": filledSlots[item].value, 
                        "resolved": filledSlots[item].resolutions.resolutionsPerAuthority[0].values[0].value.name, 
                        "isValidated": true 
                    }; 
                    break; 
                case "ER_SUCCESS_NO_MATCH": 
                    slotValues[name] = { 
                        "synonym": filledSlots[item].value, 
                        "resolved": filledSlots[item].value, 
                        "isValidated":false 
                    }; 
                    break; 
            } 
        } else { 
            slotValues[name] = { 
                "synonym": filledSlots[item].value, 
                "resolved": filledSlots[item].value, 
                "isValidated": false 
            }; 
        } 
    },this); 
    //console.log("slot values: "+JSON.stringify(slotValues)); 
    return slotValues; 
} 
// This function delegates multi-turn dialogs to Alexa. 
// For more information about dialog directives see the link below. 
// https://developer.amazon.com/docs/custom-skills/dialog-interface-reference.html 
function delegateSlotCollection() { 
    console.log("in delegateSlotCollection"); 
    console.log("current dialogState: " + this.event.request.dialogState); 
 
    if (this.event.request.dialogState === "STARTED") { 
        console.log("in STARTED"); 
        console.log(JSON.stringify(this.event)); 
        var updatedIntent=this.event.request.intent; 
        // optionally pre-fill slots: update the intent object with slot values 
        // for which you have defaults, then return Dialog.Delegate with this 
        // updated intent in the updatedIntent property 
 
        disambiguateSlot.call(this); 
        console.log("disambiguated: " + JSON.stringify(this.event)); 
        this.emit(":delegate", updatedIntent); 
    } else if (this.event.request.dialogState !== "COMPLETED") { 
        console.log("in not completed"); 
        //console.log(JSON.stringify(this.event)); 
 
        disambiguateSlot.call(this); 
        this.emit(":delegate", updatedIntent); 
    } else { 
        console.log("in completed"); 
        //console.log("returning: "+ JSON.stringify(this.event.request.intent)); 
        // Dialog is now complete and all required slots should be filled, 
        // so call your normal intent handler. 
        return this.event.request.intent.slots; 
    } 
    return null; 
} 
// If the user said a synonym that maps to more than one value, we need to ask 
// the user for clarification. Disambiguate slot will loop through all slots and 
// elicit confirmation for the first slot it sees that resolves to more than 
// one value. 
function disambiguateSlot() { 
    let currentIntent = this.event.request.intent; 
 
    Object.keys(this.event.request.intent.slots).forEach(function(slotName) { 
        let currentSlot = this.event.request.intent.slots[slotName]; 
        let slotValue = slotHasValue(this.event.request, currentSlot.name); 
        if (currentSlot.confirmationStatus !== 'CONFIRMED' && 
            currentSlot.resolutions && 
            currentSlot.resolutions.resolutionsPerAuthority[0]) { 
 
            if (currentSlot.resolutions.resolutionsPerAuthority[0].status.code == 'ER_SUCCESS_MATCH') { 
                // if there's more than one value that means we have a synonym that 
                // mapped to more than one value. So we need to ask the user for 
                // clarification. For example if the user said "mini dog", and 
                // "mini" is a synonym for both "small" and "tiny" then ask "Did you 
                // want a small or tiny dog?" to get the user to tell you 
                // specifically what type mini dog (small mini or tiny mini). 
                if ( currentSlot.resolutions.resolutionsPerAuthority[0].values.length > 1) { 
                    let prompt = 'Which would you like'; 
                    let size = currentSlot.resolutions.resolutionsPerAuthority[0].values.length; 
                    currentSlot.resolutions.resolutionsPerAuthority[0].values.forEach(function(element, index, arr) { 
                        prompt += ` ${(index == size -1) ? ' or' : ' '} ${element.value.name}`; 
                    }); 
 
                    prompt += '?'; 
                    let reprompt = prompt; 
                    // In this case we need to disambiguate the value that they 
                    // provided to us because it resolved to more than one thing so 
                    // we build up our prompts and then emit elicitSlot. 
                    this.emit(':elicitSlot', currentSlot.name, prompt, reprompt); 
                } 
            } else if (currentSlot.resolutions.resolutionsPerAuthority[0].status.code == 'ER_SUCCESS_NO_MATCH') { 
                // Here is where you'll want to add instrumentation to your code 
                // so you can capture synonyms that you haven't defined. 
                console.log("NO MATCH FOR: ", currentSlot.name, " value: ", currentSlot.value); 

            } 
        } 
    }, this); 
} 
 
// Given the request an slot name, slotHasValue returns the slot value if one 
// was given for `slotName`. Otherwise returns false. 
function slotHasValue(request, slotName) { 
 
    let slot = request.intent.slots[slotName]; 
 
    //uncomment if you want to see the request 
    //console.log("request = "+JSON.stringify(request)); 
    let slotValue; 
 
    //if we have a slot, get the text and store it into speechOutput 
    if (slot && slot.value) { 
        //we have a value in the slot 
        slotValue = slot.value.toLowerCase(); 
        return slotValue; 
    } else { 
        //we didn't get a value in the slot. 
        return false; 
    } 
} 
 // End Skill Code
// Language Model  for reference
var interactionModel = [
  {
    "name": "AMAZON.FallbackIntent",
    "samples": []
  },
  {
    "name": "AMAZON.CancelIntent",
    "samples": []
  },
  {
    "name": "AMAZON.HelpIntent",
    "samples": []
  },
  {
    "name": "AMAZON.StopIntent",
    "samples": []
  },
  {
    "name": "rateIntent",
    "slots": [
      {
        "name": "planSlot",
        "type": "planSlotType"
      },
      {
        "name": "dobSlot",
        "type": "AMAZON.DATE",
        "samples": [
          "I was born on {dobSlot}",
          "{dobSlot}"
        ]
      },
      {
        "name": "zipCodeSlot",
        "type": "AMAZON.NUMBER",
        "samples": [
          "{zipCodeSlot}",
          "My zip code is {zipCodeSlot}"
        ]
      },
      {
        "name": "smokerSlot",
        "type": "smokerSlotType",
        "samples": [
          "{smokerSlot}"
        ]
      },
      {
        "name": "healthySlot",
        "type": "healthySlotType"
      }
    ],
    "samples": [
      "What is the rate for medigap insurance",
      "What is the rate for medicare gap insurance",
      "About rates",
      "About medigap insurance rates",
      "About medicare gap insurance rates"
    ]
  },
  {
    "name": "LaunchRequest"
  }
];
var intentsReference = [
  {
    "name": "AMAZON.FallbackIntent",
    "samples": []
  },
  {
    "name": "AMAZON.CancelIntent",
    "samples": []
  },
  {
    "name": "AMAZON.HelpIntent",
    "samples": []
  },
  {
    "name": "AMAZON.StopIntent",
    "samples": []
  },
  {
    "name": "rateIntent",
    "slots": [
      {
        "name": "planSlot",
        "type": "planSlotType"
      },
      {
        "name": "dobSlot",
        "type": "AMAZON.DATE",
        "samples": [
          "I was born on {dobSlot}",
          "{dobSlot}"
        ]
      },
      {
        "name": "zipCodeSlot",
        "type": "AMAZON.NUMBER",
        "samples": [
          "{zipCodeSlot}",
          "My zip code is {zipCodeSlot}"
        ]
      },
      {
        "name": "smokerSlot",
        "type": "smokerSlotType",
        "samples": [
          "{smokerSlot}"
        ]
      },
      {
        "name": "healthySlot",
        "type": "healthySlotType"
      }
    ],
    "samples": [
      "What is the rate for medigap insurance",
      "What is the rate for medicare gap insurance",
      "About rates",
      "About medigap insurance rates",
      "About medicare gap insurance rates"
    ]
  },
  {
    "name": "LaunchRequest"
  }
];
